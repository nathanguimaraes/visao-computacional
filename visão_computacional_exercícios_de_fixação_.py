# -*- coding: utf-8 -*-
"""Visão Computacional - Exercícios de Fixação .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13j15rnBIkRaMOo7KzwY_tJ3316S8q2Xl
"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
from google.colab import files
import os

def download_image(filename):
    """Função para forçar o download de uma imagem"""
    files.download(filename)

def display_and_download(image, filename, title="Imagem"):
    """Exibe e oferece opção para download da imagem"""
    print(f"\n{title}: {filename}")
    cv2_imshow(image)
    print("\nDeseja baixar esta imagem? (s/n)")
    if input().lower() == 's':
        download_image(filename)
        print(f"Download de {filename} concluído!")
    else:
        print(f"Download de {filename} cancelado.")

# Questão 1: Baixe a imagem vermelho.jpg, modifique as cores para preto e salve como preta.jpg <--------------------------------------
def questao1():
    print("\n=== PROCESSANDO QUESTÃO 1 ===")
    # Carregar a imagem (substitua 'vermelho.jpg' pelo caminho correto após upload)
    img = cv2.imread('vermelho.jpg')

    if img is None:
        print("Erro: Não foi possível carregar a imagem. Verifique se fez o upload de 'vermelho.jpg'.")
        return None

    # Criar uma imagem preta do mesmo tamanho
    img_preta = np.zeros_like(img)

    # Salvar a imagem preta
    cv2.imwrite('preta.jpg', img_preta)
    print("✔ preta.jpg criada com sucesso.")

    # Mostrar e oferecer download
    display_and_download(img_preta, 'preta.jpg', "Imagem Preta")
    return img_preta

# Questão 2: Desenhar quadrado branco 50x50 no centro e salvar como quadradobranco50.jpg <--------------------------------------
def questao2(img_preta):
    print("\n=== PROCESSANDO QUESTÃO 2 ===")
    if img_preta is None:
        img_preta = cv2.imread('preta.jpg')

    # Fazer uma cópia para não modificar a original
    img_quad50 = img_preta.copy()

    # Obter dimensões da imagem
    altura, largura = img_quad50.shape[:2]

    # Calcular coordenadas do centro
    centro_x, centro_y = largura // 2, altura // 2

    # Desenhar quadrado branco 50x50 no centro
    cv2.rectangle(img_quad50,
                 (centro_x - 25, centro_y - 25),
                 (centro_x + 25, centro_y + 25),
                 (255, 255, 255), -1)

    # Salvar a imagem
    cv2.imwrite('quadradobranco50.jpg', img_quad50)
    print("✔ quadradobranco50.jpg criada com sucesso.")

    # Mostrar e oferecer download
    display_and_download(img_quad50, 'quadradobranco50.jpg', "Quadrado Branco 50x50")
    return img_quad50

# Questão 3: Desenhar quadrado branco 25x25 no centro e salvar como quadradobranco25.jpg <--------------------------------------
def questao3(img_preta):
    print("\n=== PROCESSANDO QUESTÃO 3 ===")
    if img_preta is None:
        img_preta = cv2.imread('preta.jpg')

    # Fazer uma cópia para não modificar a original
    img_quad25 = img_preta.copy()

    # Obter dimensões da imagem
    altura, largura = img_quad25.shape[:2]

    # Calcular coordenadas do centro
    centro_x, centro_y = largura // 2, altura // 2

    # Desenhar quadrado branco 25x25 no centro
    cv2.rectangle(img_quad25,
                 (centro_x - 12, centro_y - 12),
                 (centro_x + 12, centro_y + 12),
                 (255, 255, 255), -1)

    # Salvar a imagem
    cv2.imwrite('quadradobranco25.jpg', img_quad25)
    print("✔ quadradobranco25.jpg criada com sucesso.")

    # Mostrar e oferecer download
    display_and_download(img_quad25, 'quadradobranco25.jpg', "Quadrado Branco 25x25")
    return img_quad25

# Questão 4: Subtrair as imagens e salvar como subtracao.jpg <--------------------------------------
def questao4():
    print("\n=== PROCESSANDO QUESTÃO 4 ===")
    # Carregar as imagens em tons de cinza
    img50 = cv2.imread('quadradobranco50.jpg', 0)
    img25 = cv2.imread('quadradobranco25.jpg', 0)

    if img50 is None or img25 is None:
        print("Erro: Imagens não encontradas. Execute as questões 2 e 3 primeiro.")
        return None

    # Subtrair as imagens (quadrado maior - quadrado menor)
    subtracao = cv2.subtract(img50, img25)

    # Salvar o resultado
    cv2.imwrite('subtracao.jpg', subtracao)
    print("✔ subtracao.jpg criada com sucesso.")

    # Mostrar e oferecer download
    display_and_download(subtracao, 'subtracao.jpg', "Subtração de Imagens")
    return subtracao

# Questão 5: Inverter cores da subtração e aplicar XOR com quadradobranco50.jpg <--------------------------------------
def questao5():
    print("\n=== PROCESSANDO QUESTÃO 5 ===")
    # Carregar as imagens em tons de cinza
    subtracao = cv2.imread('subtracao.jpg', 0)
    img50 = cv2.imread('quadradobranco50.jpg', 0)

    if subtracao is None or img50 is None:
        print("Erro: Imagens não encontradas. Execute as questões anteriores primeiro.")
        return None

    # Inverter as cores da imagem de subtração
    subtracao_invertida = cv2.bitwise_not(subtracao)

    # Aplicar operação XOR
    resultado_xor = cv2.bitwise_xor(subtracao_invertida, img50)

    # Salvar o resultado
    cv2.imwrite('resultado_final.jpg', resultado_xor)
    print("✔ resultado_final.jpg criada com sucesso.")

    # Mostrar e oferecer download
    display_and_download(resultado_xor, 'resultado_final.jpg', "Resultado Final (XOR)")
    return resultado_xor

def download_all_images():
    """Oferece opção para baixar todas as imagens de uma vez"""
    print("\nDeseja baixar TODAS as imagens geradas? (s/n)")
    if input().lower() == 's':
        for filename in ['preta.jpg', 'quadradobranco50.jpg', 'quadradobranco25.jpg',
                         'subtracao.jpg', 'resultado_final.jpg']:
            if os.path.exists(filename):
                try:
                    files.download(filename)
                    print(f"✔ {filename} baixada com sucesso!")
                except:
                    print(f"✖ Falha ao baixar {filename}")
            else:
                print(f"⚠ {filename} não encontrada")
    else:
        print("Download de todas as imagens cancelado.")

# Executanbdo as questões
def main():
    print("===== Exercícios de fixação =====")
    print("\nPor favor, faça upload da imagem 'vermelho.jpg' para o Colab")
    files.upload()

    # Verificar se o upload foi feito corretamente
    if not os.path.exists('vermelho.jpg'):
        print("\n⚠ ATENÇÃO: Você precisa fazer upload do arquivo 'vermelho.jpg' primeiro!")
        print("Por favor, execute esta célula novamente após o upload.")
        return

    # Executar cada questão
    img_preta = questao1()
    img_quad50 = questao2(img_preta)
    img_quad25 = questao3(img_preta)
    img_subtracao = questao4()
    img_resultado = questao5()

    # Oferecer opção de baixar todas as imagens
    download_all_images()

    print("\n Processamento concluído com sucesso!")

if __name__ == "__main__":
    main()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
from google.colab import files
import matplotlib.pyplot as plt
import os

def draw_grid(img, grid_size=50, color=(0, 255, 0), thickness=1):
    """Desenha um grid na imagem para facilitar o posicionamento"""
    h, w = img.shape[:2]

    # Desenhar linhas verticais
    for x in range(0, w, grid_size):
        cv2.line(img, (x, 0), (x, h), color, thickness)
        cv2.putText(img, str(x), (x+5, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1)

    # Desenhar linhas horizontais
    for y in range(0, h, grid_size):
        cv2.line(img, (0, y), (w, y), color, thickness)
        cv2.putText(img, str(y), (5, y+15), cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1)

    return img

def upload_images():
    print("Por favor, faça upload da imagem da televisão:")
    uploaded_tv = files.upload()
    tv_filename = next(iter(uploaded_tv))

    print("\nAgora, faça upload da imagem do gato:")
    uploaded_cat = files.upload()
    cat_filename = next(iter(uploaded_cat))

    return tv_filename, cat_filename

# Solicitar upload das imagens
tv_filename, cat_filename = upload_images()

# 1. Carregar e preparar a imagem da televisão com grid
tv_img = cv2.imread(tv_filename)
if tv_img is None:
    raise FileNotFoundError(f"Não foi possível carregar a imagem {tv_filename}")

tv_img_with_grid = tv_img.copy()
tv_img_with_grid = draw_grid(tv_img_with_grid)

# Mostrar a imagem com grid
plt.figure(figsize=(12, 8))
plt.imshow(cv2.cvtColor(tv_img_with_grid, cv2.COLOR_BGR2RGB))
plt.title('Imagem da TV com Grid de Referência (Coordenadas em pixels)')
plt.axis('on')
plt.show()

# 2. Recortar a televisão com base nas coordenadas
print(f"\nDimensões da imagem da TV: {tv_img.shape[1]}x{tv_img.shape[0]} pixels")
print("Observando o grid acima, digite as coordenadas para recorte:")

default_width = 270
default_height = 190
default_x = (tv_img.shape[1] - default_width) // 2
default_y = (tv_img.shape[0] - default_height) // 2 - 20

try:
    start_x = int(input(f"Coordenada X inicial (sugestão: {default_x}): ") or default_x)
    start_y = int(input(f"Coordenada Y inicial (sugestão: {default_y}): ") or default_y)
    end_x = int(input(f"Coordenada X final (sugestão: {start_x + default_width}): ") or start_x + default_width)
    end_y = int(input(f"Coordenada Y final (sugestão: {start_y + default_height}): ") or start_y + default_height)
except ValueError:
    print("Valor inválido. Usando valores padrão.")
    start_x, start_y = default_x, default_y
    end_x, end_y = start_x + default_width, start_y + default_height

# Validar coordenadas
if end_x <= start_x or end_y <= start_y:
    raise ValueError("Coordenadas inválidas: o valor final deve ser maior que o inicial")

# Recortar a TV
tv_cropped = tv_img[start_y:end_y, start_x:end_x]
if tv_cropped.size == 0:
    raise ValueError("Recorte inválido - coordenadas resultaram em imagem vazia. Ajuste as coordenadas.")

# Mostrar recorte da TV
plt.figure(figsize=(8, 6))
plt.imshow(cv2.cvtColor(tv_cropped, cv2.COLOR_BGR2RGB))
plt.title('Recorte da TV')
plt.axis('off')
plt.show()

# 3. Processar a imagem do gato
cat_img = cv2.imread(cat_filename)
if cat_img is None:
    raise FileNotFoundError(f"Não foi possível carregar a imagem {cat_filename}")

cat_img_with_grid = cat_img.copy()
cat_img_with_grid = draw_grid(cat_img_with_grid)

# Mostrar imagem do gato com grid
plt.figure(figsize=(12, 8))
plt.imshow(cv2.cvtColor(cat_img_with_grid, cv2.COLOR_BGR2RGB))
plt.title('Imagem do Gato com Grid de Referência (Coordenadas em pixels)')
plt.axis('on')
plt.show()

# 4. Definir dimensões finais baseadas no recorte da TV
final_width = tv_cropped.shape[1]
final_height = tv_cropped.shape[0]
screen_margin = 10

# 5. Redimensionar o gato para o tamanho da área útil da TV (considerando margens)
screen_width = final_width - 2*screen_margin
screen_height = final_height - 2*screen_margin

cat_resized = cv2.resize(cat_img, (screen_width, screen_height))

# 6. Criar máscara para a tela da TV
mask = np.zeros((final_height, final_width), dtype=np.uint8)
cv2.rectangle(mask,
             (screen_margin, screen_margin),
             (final_width-screen_margin, final_height-screen_margin),
             255, -1)

# 7. Aplicar máscara ao gato redimensionado
mask_resized = cv2.resize(mask, (screen_width, screen_height))
cat_masked = cv2.bitwise_and(cat_resized, cat_resized, mask=mask_resized)

# 8. Centralizar o gato na TV
delta_w = final_width - cat_masked.shape[1]
delta_h = final_height - cat_masked.shape[0]
top, bottom = delta_h//2, delta_h-(delta_h//2)
left, right = delta_w//2, delta_w-(delta_w//2)

cat_masked_padded = cv2.copyMakeBorder(cat_masked,
                                     top, bottom,
                                     left, right,
                                     cv2.BORDER_CONSTANT,
                                     value=[0, 0, 0])

# 9. Inverter a TV horizontalmente
tv_flip_horizontal = cv2.flip(tv_cropped, 1)

# 10. Verificar e ajustar dimensões finais
print("\nVerificação final de dimensões:")
print(f"TV: {tv_flip_horizontal.shape[1]}x{tv_flip_horizontal.shape[0]}")
print(f"Gato: {cat_masked_padded.shape[1]}x{cat_masked_padded.shape[0]}")

if tv_flip_horizontal.shape != cat_masked_padded.shape:
    print("Ajustando dimensões para combinar...")
    cat_masked_padded = cv2.resize(cat_masked_padded, (tv_flip_horizontal.shape[1], tv_flip_horizontal.shape[0]))

# 11. Combinar as imagens
result_img = cv2.addWeighted(tv_flip_horizontal, 0.5, cat_masked_padded, 0.5, 0)

# Mostrar resultado final
plt.figure(figsize=(10, 8))
plt.imshow(cv2.cvtColor(result_img, cv2.COLOR_BGR2RGB))
plt.title('Resultado Final - Gato na TV')
plt.axis('off')
plt.show()

# Salvar resultado
output_filename = 'gato_na_tv_final.jpg'
cv2.imwrite(output_filename, result_img)
print(f"\nImagem resultante salva como {output_filename}")

# Opção para download
if input("Deseja baixar a imagem resultante? (s/n): ").lower() == 's':
    files.download(output_filename)

